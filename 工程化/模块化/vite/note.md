## 现有问题

- 在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。
- 由此出现了 webpack rollup 等等的打包工具 让我们可以以模块化的方式进行应用开发 极大的提升了开发者的开发体验
- 但是 面对开发的应用越来越庞大 js 代码量以指数级增长 项目中包含的模块也已经数千个
- 此时这些打包工具就面临了性能瓶颈 启动开发服务需要花费很长时间甚至几分钟 即便有 HMR 修改代码后也需要几秒钟时间才能反应到浏览器上
- 这种迟钝感极大的影响开发者的开发效率

## vite

- vite 旨在利用生态系统中的新进展解决上述问题：
  1. 浏览器开始原生支持 ES 模块
  2. 越来越多 JavaScript 工具使用编译型语言编写例如 ES build。

## 如何解决缓慢的服务器启动

- 当冷启动开发服务器时，传统打包工具的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。
- Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。
- 依赖 大多为在开发时不会变动的纯 JavaScript。
  - 一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。
  - 依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。
  - Vite 将会使用 esbuild 预构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。
- 源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。
  - Vite 以 原生 ESM 方式提供源码。
  - 这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。
  - 根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

## 缓慢的更新

- 基于打包器启动时，重建整个包的效率很低。原因显而易见：因为这样更新速度会随着应用体积增长而直线下降。
- 为了优化打包效率
  - 一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面。
  - 同时打包器支持了动态模块热替换（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。
  - 这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。
- 在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。
- Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

## 为什么生产环境仍需打包

- 尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。
- 为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。

## 为何不用 ESBuild 打包

- 尽管 ESBuild 很快 但是其生态目前并不强大 为了拥有更好的生态 Vite 兼容了 Rollup 灵活的插件跟 API 基础建设
- 所以 Rollup 提供了更好的性能与灵活性方面的权衡
- 随着 ESBuild 生态的稳定 还是会依靠 ESBuild 实现性能上的提升
