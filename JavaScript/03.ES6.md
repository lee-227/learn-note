## var let const
- ES6之前，只存在全局作用域以及函数作用域，ES6新增了块级作用域，而 let const 声明的变量就存在于块级作用域下。
- var 命令会进行变量提升，而 const let 不会。
  ```js
  // var 的情况
  console.log(foo); // 输出undefined
  var foo = 2;

  // let 的情况
  console.log(bar); // 报错ReferenceError
  let bar = 2;
  ```
- **暂时性死区**：只要块级作用域内存在 let const 命令，那么该命令声明的变量就会绑定此区域，不再受外部影响。**ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。**
  ```js
  var temp = 111
  if(true){
    temp = 222
    let temp
  }
  //上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，
  //导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
  ```
- 同一作用域内不允许变量重复声明，var 除外。
  ```js
  var a = 1
  var a = 2
  // 不会报错

  var b = 1
  let b = 2
  // 抛出 b 已经被声明的错误
  ```
- const 声明一个只读的常量，且声明时就要初始化。const 存储复合数据类型时，允许修改复合数据，不允许修改 const 变量存储的指向复合数据的指针。

## 变量的解构赋值

### 数组
- 本质上，这种写法属于**模式匹配**，只要两边模式相同，左边的变量就会被赋予对应的值。**如果解构不成功，变量的值就等于undefined。**
  ```js
  // 完全解构
  let [foo, [[bar], baz]] = [1, [[2], 3]];
  foo // 1
  bar // 2
  baz // 3

  let [ , , third] = ["foo", "bar", "baz"];
  third // "baz"

  let [head, ...tail] = [1, 2, 3, 4];
  head // 1
  tail // [2, 3, 4]

  let [x, y, ...z] = ['a'];
  x // "a"
  y // undefined
  z // []
  
  // 不完全解构
  let [a, [b], d] = [1, [2, 3], 4];
  a // 1
  b // 2
  d // 4
  ```
- 如果等号右边的不是可遍历结构，将会报错。
  ```js
  // 报错
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
  // 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口
  // （前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
  ```
- 默认值，ES6 内部使用严格相等运算符，判断一个位置是否有值。多以，当一个数组成员严格等于 undefined ，默认值才会生效
  ```js
  let [foo = true] = [];
  foo // true

  let [x, y = 'b'] = ['a']; // x='a', y='b'
  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

  let [x = 1] = [null];
  x // null
  ```
- 如果默认值是一个表达式，那么这么表达式**惰性求值**，只有在用到的时候，才会计算。
  ```js
  function f() {
    console.log('aaa');
  }
  let [x = f()] = [];// 函数f不会运行,使用x时且命中默认值时才会执行函数f
  ```
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
  ```js
  let [x = 1, y = x] = [];     // x=1; y=1
  let [x = 1, y = x] = [2];    // x=2; y=2
  let [x = 1, y = x] = [1, 2]; // x=1; y=2
  let [x = y, y = 1] = [];     // ReferenceError: y is not defined
  ```

### 对象
- 数组通过下标命中，而对象的解构要求变量必须与属性同名，才能取到正确的值。**解构失败就等于 undefined。**
  ```js
  let { bar,baz } = { foo: 'aaa', bar: 'bbb' };
  bar // bbb
  baz // undefined
  ```
- 当变量名已经存在时可以进行重命名。
  ```js
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。
  // 真正被赋值的是后者，而不是前者。
  ```
- 默认值等同于数组，必须严格相等 undefined 。
  ```js
  var {x = 3} = {};
  x // 3

  var {x, y = 5} = {x: 1};
  x // 1
  y // 5
  ```
### 特殊用途
- 交换两个变量的值
  ```js
  let x = 1;
  let y = 2;
  [x, y] = [y, x];
  x // 2
  y // 1
  ```

## 模板字符串
- 使用 `` 包装的字符串，支持换行，使用 ${} 嵌入变量。
  ```js
  let name = 'lee'
  let str = `我的名字是${name}`
  str // 我的名字是lee
  ```
- 带标签的模板字符串
  ```js
  let name = 'lee';
  function transStr(arr, name) {
    console.log(arr, name); // arr >> [ 'name ', ' is me' ] name >> lee
    name = name === 'lee' ? '李' : 'unknow';
    return arr[0] + name + arr[1];
  }
  let str = transStr`name ${name} is me`;
  console.log(str); // name 李 is me
  ```

### 字符串的扩展方法
- startsWith endsWith includes
  ```js
  let name = 'lee is niu';
  console.log(name.startsWith('lee')); // true
  console.log(name.endsWith('niu')); // true
  console.log(name.includes('is')); // true
  ```

## 函数扩展

### 参数默认值
- ES6 允许为函数参数设置默认值。
  ```js
  function log(x, y = 'World') {
    console.log(x, y);
  }

  log('Hello') // Hello World
  log('Hello', 'China') // Hello China
  log('Hello', '') // Hello
  ```
- 与解构默认值结合使用
  ```js
  function foo({x, y = 5}) {
    console.log(x, y);
  }

  foo({}) // undefined 5
  foo({x: 1}) // 1 5
  foo({x: 1, y: 2}) // 1 2
  foo() // TypeError: Cannot read property 'x' of undefined
  // 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。
  // 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。
  // 如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。
  // 通过提供函数参数的默认值，就可以避免这种情况。
  function foo({x, y = 5} = {}) {
    console.log(x, y);
  }
  foo() // undefined 5
  ```
- 函数的 length 属性
  
  指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
  ```js
  (function (a) {}).length // 1
  (function (a = 5) {}).length // 0
  (function (a, b, c = 5) {}).length // 2
  ```
- 参数作用域问题！！！
  
  一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

  ```js
  var x = 1;
  function f(x, y = x) {
    console.log(y);
  }
  f(2) // 2

  // 解释：运行f时参数形成独立的作用域 
  // let x,let y = x(刚声明的x，因为在同一作用域)  
  // x = 传入的参数2  
  // 输出2
  ```
  ```js
  let x = 1;
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // 1
  // 解释：
  // 函数运行时let y = x 此时x = 全局变量x  所以y = 1
 
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let y = x 此时函数内代码未执行 找不到定义的x变量  所以报错
  ```
  ```js
  var x = 1;
  function foo(x = x) {
    // ...
  }

  foo() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let x = x 暂时性死区 所以报错
  ```
  ```js
  let foo = 'outer';
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar(); // outer
  // 解释：
  // 函数运行时let func = ()=>{foo} foo指向全局变量 foo 
 
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar() // ReferenceError: foo is not defined
  // 解释：
  // 函数运行时let func = ()=>{foo} 找不到foo变量 报错 
  ```
  ```js
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    var x = 3;
    y();
    console.log(x);
  }
  foo() // 3
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为三个作用域 
  // 全局x=1 参数作用域x=2 函数内部作用域x=3 输出x 输出内部作用域x = 3
 
 
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    x = 3;
    y();
    console.log(x);
  }
  foo() // 2
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为两个作用域 
  // 全局x=1 参数作用域x 函数内x指向参数作用域的x 执行x=3 再执行y之后 x被赋值为2
  ```

### rest 剩余参数
  
  ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

  **注意：**
  1. rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错
  2. 函数的length属性，不包括 rest 参数
   
  ```js
  function add(...values) {
    let sum = 0;
    for (var val of values) {
      sum += val;
    }
    return sum;
  }
  add(2, 5, 3) // 10
  ```

### 箭头函数
- ES6 允许使用“箭头”（=>）定义函数。**如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。**箭头函数可以与变量解构结合使用。
- **注意点：**
  1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
  2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  3. 不可以使用arguments对象，该对象在函数体内不存在。可以用 rest 参数代替。
  4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
  ```js
  箭头函数本身并没有this，所以不可以用做构造函数，它的this是引用的外层函数的this，
  所以他的this指向是固定的。普通函数的this是不固定的，他永远指向调用这个函数的对象，
  而箭头函数this要看其父作用域的this。
  ```
- 不适合场合
  
  由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。
  1. 第一个场合是定义对象的方法，且该方法内部包括this。
  ```js
  const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
    }
  }
  // this指向全区对象 报错
  ```
  2. 第二个场合是需要动态this的时候，也不应使用箭头函数。
  ```js
  var button = document.getElementById('press');
  button.addEventListener('click', () => {
    this.classList.toggle('on');
  });
  // 此时this指向全局对象 不是指向button了
  ```

### 尾调用优化
- 尾调用（Tail Call）是函数式编程的一个重要概念，是指某个函数的最后一步是调用另一个函数。
  ```js
  // 尾调用
  function f(x){
    return g(x);
  }

  // 情况一
  function f(x){
    let y = g(x);
    return y;
  }
  // 情况二
  function f(x){
    return g(x) + 1;
  }
  // 情况三
  function f(x){
    g(x);
  }
  // 情况一：调用完g之后还有赋值操作
  // 情况二：调用g之后还有运算操作
  // 情况三：调用完之后 return undefined操作

  //  尾调用不一定出现在函数尾部，只要是最后一步操作即可。
  function f(x) {
    if (x > 0) {
      return m(x)
    }
    return n(x);
  }
  // m n 都属于尾调用
  ```
- 尾调用的好处就是在调用栈中不会保存外层函数，外层函数会被直接出栈，节省内存。
- 尾递归
  
  递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误，但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

  ```js
  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }
  factorial(5) // 120 会产生许多调用记录

  function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }
  factorial(5, 1) // 120
  ```

## 数组扩展

### 扩展运算符
- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
  ```js
  // 复制数组
  const a1 = [1,2,3]
  const a2 = [...a1] // 数组扩展运算
  const [...a3] = a1 // 解构运算

  // 合并数组
  const a1 = [1,2]
  const a2 = [3,4]
  const a3 = a1.concat(a2) // ES5 数组合并的方法
  const a4 = [...a1,...a2] // ES6 扩展运算合并
  // 对于成员来讲 都是浅拷贝
  const a1 = [{ foo: 1 }];
  const a2 = [{ bar: 2 }];
  const a3 = a1.concat(a2);
  const a4 = [...a1, ...a2];
  console.log(a3[0] === a4[0]) // true
  console.log(a3[0] === a1[0]) // true
  console.log(a1[0] === a4[0]) // true

  // 与解构赋值结合
  let a = list[0]; let rest = list.slice(1) // ES5
  let [a, ...rest] = list // ES6

  // 字符串
  [...'hello'] // [ "h", "e", "l", "l", "o" ] 将字符串转为真正的数组

  // 任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。
  let nodeList = document.querySelectorAll('div');
  let array = [...nodeList];
  ```

### Array.from()
- Array.from方法用于**将两类对象转为真正的数组**：**类似数组的对象**（array-like object）和**可遍历（iterable）的对象**（包括 ES6 新增的数据结构 Set 和 Map）。实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
  ```js
  let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
  };
  // ES5的写法
  var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
  // ES6的写法
  let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
  ```
### 数组实例的find()跟findIndex()
- 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
  ```js
  [1, 4, -5, 10].find((n) => n < 0) // -5
  ```
- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
  ```js
  [1, 5, 10, 15].findIndex(function(value, index, arr) {
    return value > 9;
  }) // 2
  ```
- 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。
  ```js
  [NaN].indexOf(NaN) // -1
  [NaN].findIndex(y => Object.is(NaN, y)) // 0
  ```

### 数组实例的fill()
- fill方法使用给定值，填充一个数组。fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
  ```js
  ['a', 'b', 'c'].fill(7) // [7, 7, 7]
  new Array(3).fill(7) // [7, 7, 7]
  ```
- fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
  ```js
  ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']
  ```

- **如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。**
  ```js
  let arr = new Array(3).fill({name: "Mike"});
  arr[0].name = "Ben";
  arr // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

  let arr = new Array(3).fill([]);
  arr[0].push(5);
  arr // [[5], [5], [5]]
  ```

### 数组实例的entires(),keys(),values()
- keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
  ```js
  for (let index of ['a', 'b'].keys()) {
    console.log(index); // 0 1
  }

  for (let elem of ['a', 'b'].values()) {
    console.log(elem); // a b
  }

  for (let [index, elem] of ['a', 'b'].entries()) {
    console.log(index, elem); // 0,a 1,b
  }
  ```
### 数组实例的includes()
- Array.prototype.includes方法**返回一个布尔值**，表示某个数组是否包含给定的值，与字符串的includes方法类似。
  ```js
  [1, 2, 3].includes(2)     // true
  [1, 2, 3].includes(4)     // false
  [1, 2, NaN].includes(NaN) // true
  ```
- 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置。如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始
  ```js
  [1, 2, 3].includes(3, 3);  // false
  [1, 2, 3].includes(3, -1); // true
  ```

## 对象扩展
### 属性的简洁表示
- ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
  ```js
  const foo = 'bar';
  const baz = {foo};
  baz // {foo: "bar"}

  // 除了属性简写，方法也可以简写。
  const o = {
    method() {
      return "Hello!";
    }
  };
  ```

### 属性名表达式
- JavaScript 定义对象的属性，有两种方法。
  ```js
  obj.foo = true;
  obj['a' + 'bc'] = 123;

  let propKey = 'foo';
  let obj = {
    [propKey]: true,
    ['a' + 'bc']: 123
  };
  ```

### 属性的可枚举性和遍历
- 可枚举性，对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
  ```js
  let obj = { foo: 123 };
  Object.getOwnPropertyDescriptor(obj, 'foo')
  //  {
  //    value: 123,
  //    writable: true,
  //    enumerable: true,
  //    configurable: true
  //  }
  ```
  描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略enumerable为false的属性。
  
  1. for...in循环：只遍历对象自身的和继承的可枚举的属性。
  2. Object.keys()：返回对象自身的所有可枚举的属性的键名。
  3. JSON.stringify()：只串行化对象自身的可枚举的属性。
  4. Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
  **其中只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。**
- 遍历
  1. for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
  2. Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
  3. Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
  4. Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
  5. Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。
   
  **以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。**

  1. 首先遍历所有数值键，按照数值升序排列。
  2. 其次遍历所有字符串键，按照加入时间升序排列。
  3. 最后遍历所有 Symbol 键，按照加入时间升序排列。
   
### super 关键字
- this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向**当前对象的原型对象**。
  ```js
  const proto = {
    foo: 'hello'
  };
  const obj = {
    foo: 'world',
    find() {
      return super.foo;
    }
  };
  Object.setPrototypeOf(obj, proto);
  obj.find() // "hello"
  ```
- super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。
  ```js
  // 报错
  const obj = {
    foo: super.foo // super 用在了属性中
  }
  // 报错
  const obj = {
    foo: () => super.foo // super 用在了函数中
  }
  // 报错
  const obj = {
    foo: function () {
      return super.foo // super 用在了函数中
    }
  }
  ```

### 对象的扩展运算符
- 解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。
  ```js
  let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
  x // 1
  y // 2
  z // { a: 3, b: 4 }
  ```
- 解构赋值必须是最后一个参数，否则会报错。
- 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
- 扩展运算符的解构赋值，不能复制继承自原型对象的属性。
- 数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
  ```js
  let foo = { ...['a', 'b', 'c'] };
  foo
  // {0: "a", 1: "b", 2: "c"}
  ```
- 扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。
  ```js
  {...'hello'}
  // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
  ```
- 如果扩展运算符后面不是对象，则会自动将其转为对象。
  ```js
  // 等同于 {...Object(1)}
  {...1} // {}
  ```

### 对象的拷贝
```js
let aClone = { ...a, ...b };
// 等同于
let aClone = Object.assign({}, a, b);
// 只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

## 对象的新增方法
### Object.is方法
- 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
  ```js
  Object.is('foo', 'foo')  // true
  Object.is({}, {}) // false
  ```
- 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
  ```js
  +0 === -0 //true
  NaN === NaN // false

  Object.is(+0, -0) // false
  Object.is(NaN, NaN) // true
  ```
### Object.assign()
- 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。**如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。**
  ```js
  const target = { a: 1 };

  const source1 = { b: 2 };
  const source2 = { c: 3 };

  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
  ```
- 注意：
  ```js
  const obj = {a: 1};
  Object.assign(obj) === obj // true

  typeof Object.assign(2) // "object"

  Object.assign(undefined) // 报错
  Object.assign(null) // 报错

  // 非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同
  // 首先，这些参数都会转成对象，如果无法转成对象，就会跳过。
  // 这意味着，如果undefined和null不在首参数，就不会报错。
  let obj = {a: 1};
  Object.assign(obj, undefined) === obj // true
  Object.assign(obj, null) === obj // true

  const v1 = 'abc';
  const v2 = true;
  const v3 = 10;
  const obj = Object.assign({}, v1, v2, v3);
  console.log(obj); // { "0": "a", "1": "b", "2": "c" }
  ```
- Object.assign拷贝的属性是有限制的，**只拷贝源对象的自身属性**（**不拷贝继承属性**），也**不拷贝不可枚举的属性**（enumerable: false）。**属性名为 Symbol 值的属性，也会被Object.assign拷贝。**
  ```js
  Object.assign({b: 'c'},
  Object.defineProperty({}, 'invisible', {
      enumerable: false,
      value: 'hello'
    })
  )
  // { b: 'c' }

  Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
  // { a: 'b', Symbol(c): 'd' }
  ```
- Object.assign方法实行的是**浅拷贝**，而不是深拷贝。也就是说，**如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用**。嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是**替换**，而不是添加。
  ```js
  const obj1 = {a: {b: 1}};
  const obj2 = Object.assign({}, obj1);
  obj1.a.b = 2;
  obj2.a.b // 2

  const target = { a: { b: 'c', d: 'e' } }
  const source = { a: { b: 'hello' } }
  Object.assign(target, source)
  // { a: { b: 'hello' } }
  ```
- Object.assign可以用来处理数组，但是会把数组视为对象。
  ```js
  Object.assign([1, 2, 3], [4, 5])
  // [4, 5, 3]
  ```
- Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
  ```js
  const source = {
    get foo() { return 1 }
  };
  const target = {};
  Object.assign(target, source)
  // { foo: 1 } // 只复制值 而不是 取值函数
  ```

### Object.getOwnPropertyDescriptors()
- 返回某个对象属性的描述对象（descriptor）
  ```js
  const obj = {
    foo: 123,
    get bar() { return 'abc' }
  };

  Object.getOwnPropertyDescriptors(obj)
  // { foo:
  //    { value: 123,
  //      writable: true,
  //      enumerable: true,
  //      configurable: true },
  //   bar:
  //    { get: [Function: get bar],
  //      set: undefined,
  //      enumerable: true,
  //      configurable: true } }
  ```

### __proto__属性
- __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。
  ```js
  // es5 的写法
  const obj = {
    method: function() { ... }
  };
  obj.__proto__ = someOtherObj;

  // es6 的写法
  var obj = Object.create(someOtherObj);
  obj.method = function() { ... };
  ```

### Object.setPrototypeOf()
- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。
  ```js
  Object.setPrototypeOf(object, prototype)
  ```

### Object.getPrototypeOf()
- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。
  ```js
  function Rectangle() {
    // ...
  }
  const rec = new Rectangle();

  Object.getPrototypeOf(rec) === Rectangle.prototype
  // true

  Object.setPrototypeOf(rec, Object.prototype);
  Object.getPrototypeOf(rec) === Rectangle.prototype
  // false
  ```

### keys values entries fromEntries
- Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
  ```js
  var obj = { foo: 'bar', baz: 42 };
  Object.keys(obj)
  // ["foo", "baz"]
  ```
- Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
  ```js
  const obj = { foo: 'bar', baz: 42 };
  Object.values(obj)
  // ["bar", 42]
  ```
- Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
  ```js
  const obj = { foo: 'bar', baz: 42 };
  Object.entries(obj)
  // [ ["foo", "bar"], ["baz", 42] ]
  ```
- Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
  ```js
  Object.fromEntries([
    ['foo', 'bar'],
    ['baz', 42]
  ])
  // { foo: "bar", baz: 42 }
  ```

## Symbol
### 概述
- ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
  ```js
  let s = Symbol();
  typeof s // "symbol"
  // 变量s就是一个独一无二的值。
  // typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。
  ```
- Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol **是一个原始类型的值**，不是对象。也就是说，由于 **Symbol 值不是对象，所以不能添加属性**。基本上，它是一种类似于字符串的数据类型。
- Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。主要是为了在控制台显示，或者转为字符串时，比较容易区分。
  ```js
  let s1 = Symbol('foo');
  s1 // Symbol(foo)
  s1.toString() // "Symbol(foo)"

  // 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，
  // 将其转为字符串，然后才生成一个 Symbol 值。
  const obj = {
    toString() {
      return 'abc';
    }
  };
  const sym = Symbol(obj);
  sym // Symbol(abc)
  ```
- Symbol函数的参数只是表示对当前 Symbol 值的描述，因此**相同参数的Symbol函数的返回值是不相等的。**
  ```js
  let s1 = Symbol();
  let s2 = Symbol();
  s1 === s2 // false

  let s1 = Symbol('foo');
  let s2 = Symbol('foo');
  s1 === s2 // false
  ```
- 注意：
  
  1. Symbol 值不能与其他类型的值进行运算，会报错。
  2. Symbol 值可以显式转为字符串。
  3. Symbol 值也可以转为布尔值，但是不能转为数值。 
   
    
### Symbol.prototype.description
- ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。
  ```js
  const sym = Symbol('foo');
  sym.description // "foo"

  // 不适用descriptioin时怎么获取描述
  const sym = Symbol('foo');
  String(sym) // "Symbol(foo)"
  sym.toString() // "Symbol(foo)"
  ```

### 作为属性名的Symbol
- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
  ```js
  let mySymbol = Symbol();

  let a = {};
  a[mySymbol] = 'Hello!';

  let a = {
    [mySymbol]: 'Hello!';
  };

  let a = {};
  Object.defineProperty(a, mySymbol, { value: 'Hello!' });
  ```
- 注意:
  
  1. Symbol 值作为对象属性名时，不能用点运算符。
  2. 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
  3. Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。