## var let const
- ES6之前，只存在全局作用域以及函数作用域，ES6新增了块级作用域，而 let const 声明的变量就存在于块级作用域下。
- var 命令会进行变量提升，而 const let 不会。
  ```js
  // var 的情况
  console.log(foo); // 输出undefined
  var foo = 2;

  // let 的情况
  console.log(bar); // 报错ReferenceError
  let bar = 2;
  ```
- **暂时性死区**：只要块级作用域内存在 let const 命令，那么该命令声明的变量就会绑定此区域，不再受外部影响。**ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。**
  ```js
  var temp = 111
  if(true){
    temp = 222
    let temp
  }
  //上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，
  //导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
  ```
- 同一作用域内不允许变量重复声明，var 除外。
  ```js
  var a = 1
  var a = 2
  // 不会报错

  var b = 1
  let b = 2
  // 抛出 b 已经被声明的错误
  ```
- const 声明一个只读的常量，且声明时就要初始化。const 存储复合数据类型时，允许修改复合数据，不允许修改 const 变量存储的指向复合数据的指针。

## 变量的解构赋值

### 数组
- 本质上，这种写法属于**模式匹配**，只要两边模式相同，左边的变量就会被赋予对应的值。**如果解构不成功，变量的值就等于undefined。**
  ```js
  // 完全解构
  let [foo, [[bar], baz]] = [1, [[2], 3]];
  foo // 1
  bar // 2
  baz // 3

  let [ , , third] = ["foo", "bar", "baz"];
  third // "baz"

  let [head, ...tail] = [1, 2, 3, 4];
  head // 1
  tail // [2, 3, 4]

  let [x, y, ...z] = ['a'];
  x // "a"
  y // undefined
  z // []
  
  // 不完全解构
  let [a, [b], d] = [1, [2, 3], 4];
  a // 1
  b // 2
  d // 4
  ```
- 如果等号右边的不是可遍历结构，将会报错。
  ```js
  // 报错
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
  // 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口
  // （前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
  ```
- 默认值，ES6 内部使用严格相等运算符，判断一个位置是否有值。多以，当一个数组成员严格等于 undefined ，默认值才会生效
  ```js
  let [foo = true] = [];
  foo // true

  let [x, y = 'b'] = ['a']; // x='a', y='b'
  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

  let [x = 1] = [null];
  x // null
  ```
- 如果默认值是一个表达式，那么这么表达式**惰性求值**，只有在用到的时候，才会计算。
  ```js
  function f() {
    console.log('aaa');
  }
  let [x = f()] = [];// 函数f不会运行,使用x时且命中默认值时才会执行函数f
  ```
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
  ```js
  let [x = 1, y = x] = [];     // x=1; y=1
  let [x = 1, y = x] = [2];    // x=2; y=2
  let [x = 1, y = x] = [1, 2]; // x=1; y=2
  let [x = y, y = 1] = [];     // ReferenceError: y is not defined
  ```

### 对象
- 数组通过下标命中，而对象的解构要求变量必须与属性同名，才能取到正确的值。**解构失败就等于 undefined。**
  ```js
  let { bar,baz } = { foo: 'aaa', bar: 'bbb' };
  bar // bbb
  baz // undefined
  ```
- 当变量名已经存在时可以进行重命名。
  ```js
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。
  // 真正被赋值的是后者，而不是前者。
  ```
- 默认值等同于数组，必须严格相等 undefined 。
  ```js
  var {x = 3} = {};
  x // 3

  var {x, y = 5} = {x: 1};
  x // 1
  y // 5
  ```
### 特殊用途
- 交换两个变量的值
  ```js
  let x = 1;
  let y = 2;
  [x, y] = [y, x];
  x // 2
  y // 1
  ```

## 模板字符串
- 使用 `` 包装的字符串，支持换行，使用 ${} 嵌入变量。
  ```js
  let name = 'lee'
  let str = `我的名字是${name}`
  str // 我的名字是lee
  ```
- 带标签的模板字符串
  ```js
  let name = 'lee';
  function transStr(arr, name) {
    console.log(arr, name); // arr >> [ 'name ', ' is me' ] name >> lee
    name = name === 'lee' ? '李' : 'unknow';
    return arr[0] + name + arr[1];
  }
  let str = transStr`name ${name} is me`;
  console.log(str); // name 李 is me
  ```

### 字符串的扩展方法
- startsWith endsWith includes
  ```js
  let name = 'lee is niu';
  console.log(name.startsWith('lee')); // true
  console.log(name.endsWith('niu')); // true
  console.log(name.includes('is')); // true
  ```

## 函数扩展

### 参数默认值
- ES6 允许为函数参数设置默认值。
  ```js
  function log(x, y = 'World') {
    console.log(x, y);
  }

  log('Hello') // Hello World
  log('Hello', 'China') // Hello China
  log('Hello', '') // Hello
  ```
- 与解构默认值结合使用
  ```js
  function foo({x, y = 5}) {
    console.log(x, y);
  }

  foo({}) // undefined 5
  foo({x: 1}) // 1 5
  foo({x: 1, y: 2}) // 1 2
  foo() // TypeError: Cannot read property 'x' of undefined
  // 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。
  // 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。
  // 如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。
  // 通过提供函数参数的默认值，就可以避免这种情况。
  function foo({x, y = 5} = {}) {
    console.log(x, y);
  }
  foo() // undefined 5
  ```
- 函数的 length 属性
  
  指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
  ```js
  (function (a) {}).length // 1
  (function (a = 5) {}).length // 0
  (function (a, b, c = 5) {}).length // 2
  ```
- 参数作用域问题！！！
  
  一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

  ```js
  var x = 1;
  function f(x, y = x) {
    console.log(y);
  }
  f(2) // 2

  // 解释：运行f时参数形成独立的作用域 
  // let x,let y = x(刚声明的x，因为在同一作用域)  
  // x = 传入的参数2  
  // 输出2
  ```
  ```js
  let x = 1;
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // 1
  // 解释：
  // 函数运行时let y = x 此时x = 全局变量x  所以y = 1
 
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let y = x 此时函数内代码未执行 找不到定义的x变量  所以报错
  ```
  ```js
  var x = 1;
  function foo(x = x) {
    // ...
  }

  foo() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let x = x 暂时性死区 所以报错
  ```
  ```js
  let foo = 'outer';
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar(); // outer
  // 解释：
  // 函数运行时let func = ()=>{foo} foo指向全局变量 foo 
 
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar() // ReferenceError: foo is not defined
  // 解释：
  // 函数运行时let func = ()=>{foo} 找不到foo变量 报错 
  ```
  ```js
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    var x = 3;
    y();
    console.log(x);
  }
  foo() // 3
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为三个作用域 
  // 全局x=1 参数作用域x=2 函数内部作用域x=3 输出x 输出内部作用域x = 3
 
 
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    x = 3;
    y();
    console.log(x);
  }
  foo() // 2
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为两个作用域 
  // 全局x=1 参数作用域x 函数内x指向参数作用域的x 执行x=3 再执行y之后 x被赋值为2
  ```

### rest 剩余参数
  
  ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

  **注意：**
  1. rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错
  2. 函数的length属性，不包括 rest 参数
   
  ```js
  function add(...values) {
    let sum = 0;
    for (var val of values) {
      sum += val;
    }
    return sum;
  }
  add(2, 5, 3) // 10
  ```

### 箭头函数
- ES6 允许使用“箭头”（=>）定义函数。**如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。**箭头函数可以与变量解构结合使用。
- **注意点：**
  1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
  2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  3. 不可以使用arguments对象，该对象在函数体内不存在。可以用 rest 参数代替。
  4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
  ```js
  箭头函数本身并没有this，所以不可以用做构造函数，它的this是引用的外层函数的this，
  所以他的this指向是固定的。普通函数的this是不固定的，他永远指向调用这个函数的对象，
  而箭头函数this要看其父作用域的this。
  ```
- 不适合场合
  
  由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。
  1. 第一个场合是定义对象的方法，且该方法内部包括this。
  ```js
  const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
    }
  }
  // this指向全区对象 报错
  ```
  2. 第二个场合是需要动态this的时候，也不应使用箭头函数。
  ```js
  var button = document.getElementById('press');
  button.addEventListener('click', () => {
    this.classList.toggle('on');
  });
  // 此时this指向全局对象 不是指向button了
  ```

### 尾调用优化
- 尾调用（Tail Call）是函数式编程的一个重要概念，是指某个函数的最后一步是调用另一个函数。
  ```js
  // 尾调用
  function f(x){
    return g(x);
  }

  // 情况一
  function f(x){
    let y = g(x);
    return y;
  }
  // 情况二
  function f(x){
    return g(x) + 1;
  }
  // 情况三
  function f(x){
    g(x);
  }
  // 情况一：调用完g之后还有赋值操作
  // 情况二：调用g之后还有运算操作
  // 情况三：调用完之后 return undefined操作

  //  尾调用不一定出现在函数尾部，只要是最后一步操作即可。
  function f(x) {
    if (x > 0) {
      return m(x)
    }
    return n(x);
  }
  // m n 都属于尾调用
  ```
- 尾调用的好处就是在调用栈中不会保存外层函数，外层函数会被直接出栈，节省内存。
- 尾递归
  
  递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误，但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

  ```js
  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }
  factorial(5) // 120 会产生许多调用记录

  function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }
  factorial(5, 1) // 120
  ```
  