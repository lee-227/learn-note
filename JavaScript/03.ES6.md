## var let const
- ES6之前，只存在全局作用域以及函数作用域，ES6新增了块级作用域，而 let const 声明的变量就存在于块级作用域下。
- var 命令会进行变量提升，而 const let 不会。
  ```js
  // var 的情况
  console.log(foo); // 输出undefined
  var foo = 2;

  // let 的情况
  console.log(bar); // 报错ReferenceError
  let bar = 2;
  ```
- **暂时性死区**：只要块级作用域内存在 let const 命令，那么该命令声明的变量就会绑定此区域，不再受外部影响。**ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。**
  ```js
  var temp = 111
  if(true){
    temp = 222
    let temp
  }
  //上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，
  //导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
  ```
- 同一作用域内不允许变量重复声明，var 除外。
  ```js
  var a = 1
  var a = 2
  // 不会报错

  var b = 1
  let b = 2
  // 抛出 b 已经被声明的错误
  ```
- const 声明一个只读的常量，且声明时就要初始化。const 存储复合数据类型时，允许修改复合数据，不允许修改 const 变量存储的指向复合数据的指针。

## 变量的解构赋值

### 数组
- 本质上，这种写法属于**模式匹配**，只要两边模式相同，左边的变量就会被赋予对应的值。**如果解构不成功，变量的值就等于undefined。**
  ```js
  // 完全解构
  let [foo, [[bar], baz]] = [1, [[2], 3]];
  foo // 1
  bar // 2
  baz // 3

  let [ , , third] = ["foo", "bar", "baz"];
  third // "baz"

  let [head, ...tail] = [1, 2, 3, 4];
  head // 1
  tail // [2, 3, 4]

  let [x, y, ...z] = ['a'];
  x // "a"
  y // undefined
  z // []
  
  // 不完全解构
  let [a, [b], d] = [1, [2, 3], 4];
  a // 1
  b // 2
  d // 4
  ```
- 如果等号右边的不是可遍历结构，将会报错。
  ```js
  // 报错
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
  // 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口
  // （前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
  ```
- 默认值，ES6 内部使用严格相等运算符，判断一个位置是否有值。多以，当一个数组成员严格等于 undefined ，默认值才会生效
  ```js
  let [foo = true] = [];
  foo // true

  let [x, y = 'b'] = ['a']; // x='a', y='b'
  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

  let [x = 1] = [null];
  x // null
  ```
- 如果默认值是一个表达式，那么这么表达式**惰性求值**，只有在用到的时候，才会计算。
  ```js
  function f() {
    console.log('aaa');
  }
  let [x = f()] = [];// 函数f不会运行,使用x时且命中默认值时才会执行函数f
  ```
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
  ```js
  let [x = 1, y = x] = [];     // x=1; y=1
  let [x = 1, y = x] = [2];    // x=2; y=2
  let [x = 1, y = x] = [1, 2]; // x=1; y=2
  let [x = y, y = 1] = [];     // ReferenceError: y is not defined
  ```

### 对象
- 数组通过下标命中，而对象的解构要求变量必须与属性同名，才能取到正确的值。**解构失败就等于 undefined。**
  ```js
  let { bar,baz } = { foo: 'aaa', bar: 'bbb' };
  bar // bbb
  baz // undefined
  ```
- 当变量名已经存在时可以进行重命名。
  ```js
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  // 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。
  // 真正被赋值的是后者，而不是前者。
  ```
- 默认值等同于数组，必须严格相等 undefined 。
  ```js
  var {x = 3} = {};
  x // 3

  var {x, y = 5} = {x: 1};
  x // 1
  y // 5
  ```
### 特殊用途
- 交换两个变量的值
  ```js
  let x = 1;
  let y = 2;
  [x, y] = [y, x];
  x // 2
  y // 1
  ```

## 模板字符串
- 使用 `` 包装的字符串，支持换行，使用 ${} 嵌入变量。
  ```js
  let name = 'lee'
  let str = `我的名字是${name}`
  str // 我的名字是lee
  ```
- 带标签的模板字符串
  ```js
  let name = 'lee';
  function transStr(arr, name) {
    console.log(arr, name); // arr >> [ 'name ', ' is me' ] name >> lee
    name = name === 'lee' ? '李' : 'unknow';
    return arr[0] + name + arr[1];
  }
  let str = transStr`name ${name} is me`;
  console.log(str); // name 李 is me
  ```

### 字符串的扩展方法
- startsWith endsWith includes
  ```js
  let name = 'lee is niu';
  console.log(name.startsWith('lee')); // true
  console.log(name.endsWith('niu')); // true
  console.log(name.includes('is')); // true
  ```

## 函数扩展

### 参数默认值
- ES6 允许为函数参数设置默认值。
  ```js
  function log(x, y = 'World') {
    console.log(x, y);
  }

  log('Hello') // Hello World
  log('Hello', 'China') // Hello China
  log('Hello', '') // Hello
  ```
- 与解构默认值结合使用
  ```js
  function foo({x, y = 5}) {
    console.log(x, y);
  }

  foo({}) // undefined 5
  foo({x: 1}) // 1 5
  foo({x: 1, y: 2}) // 1 2
  foo() // TypeError: Cannot read property 'x' of undefined
  // 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。
  // 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。
  // 如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。
  // 通过提供函数参数的默认值，就可以避免这种情况。
  function foo({x, y = 5} = {}) {
    console.log(x, y);
  }
  foo() // undefined 5
  ```
- 函数的 length 属性
  
  指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
  ```js
  (function (a) {}).length // 1
  (function (a = 5) {}).length // 0
  (function (a, b, c = 5) {}).length // 2
  ```
- 参数作用域问题！！！
  
  一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

  ```js
  var x = 1;
  function f(x, y = x) {
    console.log(y);
  }
  f(2) // 2

  // 解释：运行f时参数形成独立的作用域 
  // let x,let y = x(刚声明的x，因为在同一作用域)  
  // x = 传入的参数2  
  // 输出2
  ```
  ```js
  let x = 1;
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // 1
  // 解释：
  // 函数运行时let y = x 此时x = 全局变量x  所以y = 1
 
  function f(y = x) {
    let x = 2;
    console.log(y);
  }
  f() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let y = x 此时函数内代码未执行 找不到定义的x变量  所以报错
  ```
  ```js
  var x = 1;
  function foo(x = x) {
    // ...
  }

  foo() // ReferenceError: x is not defined
  // 解释：
  // 函数运行时let x = x 暂时性死区 所以报错
  ```
  ```js
  let foo = 'outer';
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar(); // outer
  // 解释：
  // 函数运行时let func = ()=>{foo} foo指向全局变量 foo 
 
  function bar(func = () => foo) {
    let foo = 'inner';
    console.log(func());
  }
  bar() // ReferenceError: foo is not defined
  // 解释：
  // 函数运行时let func = ()=>{foo} 找不到foo变量 报错 
  ```
  ```js
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    var x = 3;
    y();
    console.log(x);
  }
  foo() // 3
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为三个作用域 
  // 全局x=1 参数作用域x=2 函数内部作用域x=3 输出x 输出内部作用域x = 3
 
 
  var x = 1;
  function foo(x, y = function() { x = 2; }) {
    x = 3;
    y();
    console.log(x);
  }
  foo() // 2
  x // 1
  // 解释：
  // 函数运行时let x,let y = function 此时分为两个作用域 
  // 全局x=1 参数作用域x 函数内x指向参数作用域的x 执行x=3 再执行y之后 x被赋值为2
  ```

### rest 剩余参数
  
  ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

  **注意：**
  1. rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错
  2. 函数的length属性，不包括 rest 参数
   
  ```js
  function add(...values) {
    let sum = 0;
    for (var val of values) {
      sum += val;
    }
    return sum;
  }
  add(2, 5, 3) // 10
  ```

### 箭头函数
- ES6 允许使用“箭头”（=>）定义函数。**如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。**箭头函数可以与变量解构结合使用。
- **注意点：**
  1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
  2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
  3. 不可以使用arguments对象，该对象在函数体内不存在。可以用 rest 参数代替。
  4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
  ```js
  箭头函数本身并没有this，所以不可以用做构造函数，它的this是引用的外层函数的this，
  所以他的this指向是固定的。普通函数的this是不固定的，他永远指向调用这个函数的对象，
  而箭头函数this要看其父作用域的this。
  ```
- 不适合场合
  
  由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。
  1. 第一个场合是定义对象的方法，且该方法内部包括this。
  ```js
  const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
    }
  }
  // this指向全区对象 报错
  ```
  2. 第二个场合是需要动态this的时候，也不应使用箭头函数。
  ```js
  var button = document.getElementById('press');
  button.addEventListener('click', () => {
    this.classList.toggle('on');
  });
  // 此时this指向全局对象 不是指向button了
  ```

### 尾调用优化
- 尾调用（Tail Call）是函数式编程的一个重要概念，是指某个函数的最后一步是调用另一个函数。
  ```js
  // 尾调用
  function f(x){
    return g(x);
  }

  // 情况一
  function f(x){
    let y = g(x);
    return y;
  }
  // 情况二
  function f(x){
    return g(x) + 1;
  }
  // 情况三
  function f(x){
    g(x);
  }
  // 情况一：调用完g之后还有赋值操作
  // 情况二：调用g之后还有运算操作
  // 情况三：调用完之后 return undefined操作

  //  尾调用不一定出现在函数尾部，只要是最后一步操作即可。
  function f(x) {
    if (x > 0) {
      return m(x)
    }
    return n(x);
  }
  // m n 都属于尾调用
  ```
- 尾调用的好处就是在调用栈中不会保存外层函数，外层函数会被直接出栈，节省内存。
- 尾递归
  
  递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误，但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

  ```js
  function factorial(n) {
    if (n === 1) return 1;
    return n * factorial(n - 1);
  }
  factorial(5) // 120 会产生许多调用记录

  function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
  }
  factorial(5, 1) // 120
  ```

## 数组扩展

### 扩展运算符
- 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
  ```js
  // 复制数组
  const a1 = [1,2,3]
  const a2 = [...a1] // 数组扩展运算
  const [...a3] = a1 // 解构运算

  // 合并数组
  const a1 = [1,2]
  const a2 = [3,4]
  const a3 = a1.concat(a2) // ES5 数组合并的方法
  const a4 = [...a1,...a2] // ES6 扩展运算合并
  // 对于成员来讲 都是浅拷贝
  const a1 = [{ foo: 1 }];
  const a2 = [{ bar: 2 }];
  const a3 = a1.concat(a2);
  const a4 = [...a1, ...a2];
  console.log(a3[0] === a4[0]) // true
  console.log(a3[0] === a1[0]) // true
  console.log(a1[0] === a4[0]) // true

  // 与解构赋值结合
  let a = list[0]; let rest = list.slice(1) // ES5
  let [a, ...rest] = list // ES6

  // 字符串
  [...'hello'] // [ "h", "e", "l", "l", "o" ] 将字符串转为真正的数组

  // 任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。
  let nodeList = document.querySelectorAll('div');
  let array = [...nodeList];
  ```

### Array.from()
- Array.from方法用于**将两类对象转为真正的数组**：**类似数组的对象**（array-like object）和**可遍历（iterable）的对象**（包括 ES6 新增的数据结构 Set 和 Map）。实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
  ```js
  let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
  };
  // ES5的写法
  var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']
  // ES6的写法
  let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
  ```
### 数组实例的find()跟findIndex()
- 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
  ```js
  [1, 4, -5, 10].find((n) => n < 0) // -5
  ```
- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
  ```js
  [1, 5, 10, 15].findIndex(function(value, index, arr) {
    return value > 9;
  }) // 2
  ```
- 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。
  ```js
  [NaN].indexOf(NaN) // -1
  [NaN].findIndex(y => Object.is(NaN, y)) // 0 
  ```

### 数组实例的fill()
- fill方法使用给定值，填充一个数组。fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
  ```js
  ['a', 'b', 'c'].fill(7) // [7, 7, 7]
  new Array(3).fill(7) // [7, 7, 7]
  ```
- fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
  ```js
  ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']
  ```

- **如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。**
  ```js
  let arr = new Array(3).fill({name: "Mike"});
  arr[0].name = "Ben";
  arr // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

  let arr = new Array(3).fill([]);
  arr[0].push(5);
  arr // [[5], [5], [5]]
  ```

### 数组实例的entires(),keys(),values()
- keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
  ```js
  for (let index of ['a', 'b'].keys()) {
    console.log(index); // 0 1
  }

  for (let elem of ['a', 'b'].values()) {
    console.log(elem); // a b
  }

  for (let [index, elem] of ['a', 'b'].entries()) {
    console.log(index, elem); // 0,a 1,b
  }
  ```
### 数组实例的includes()
- Array.prototype.includes方法**返回一个布尔值**，表示某个数组是否包含给定的值，与字符串的includes方法类似。
  ```js
  [1, 2, 3].includes(2)     // true
  [1, 2, 3].includes(4)     // false
  [1, 2, NaN].includes(NaN) // true
  ```
- 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置。如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始
  ```js
  [1, 2, 3].includes(3, 3);  // false
  [1, 2, 3].includes(3, -1); // true
  ```

## 对象扩展
### 属性的简洁表示
- ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
  ```js
  const foo = 'bar';
  const baz = {foo};
  baz // {foo: "bar"}

  // 除了属性简写，方法也可以简写。
  const o = {
    method() {
      return "Hello!";
    }
  };
  ```

### 属性名表达式
- JavaScript 定义对象的属性，有两种方法。
  ```js
  obj.foo = true;
  obj['a' + 'bc'] = 123;

  let propKey = 'foo';
  let obj = {
    [propKey]: true,
    ['a' + 'bc']: 123
  };
  ```

### 属性的可枚举性和遍历
- 可枚举性，对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
  ```js
  let obj = { foo: 123 };
  Object.getOwnPropertyDescriptor(obj, 'foo')
  //  {
  //    value: 123,
  //    writable: true,
  //    enumerable: true,
  //    configurable: true
  //  }
  ```
  描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略enumerable为false的属性。
  
  1. for...in循环：只遍历对象自身的和继承的可枚举的属性。
  2. Object.keys()：返回对象自身的所有可枚举的属性的键名。
  3. JSON.stringify()：只串行化对象自身的可枚举的属性。
  4. Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
  **其中只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。**
- 遍历
  1. for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
  2. Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
  3. Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
  4. Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
  5. Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。
   
  **以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。**

  1. 首先遍历所有数值键，按照数值升序排列。
  2. 其次遍历所有字符串键，按照加入时间升序排列。
  3. 最后遍历所有 Symbol 键，按照加入时间升序排列。
   
### super 关键字
- this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向**当前对象的原型对象**。
  ```js
  const proto = {
    foo: 'hello'
  };
  const obj = {
    foo: 'world',
    find() {
      return super.foo;
    }
  };
  Object.setPrototypeOf(obj, proto);
  obj.find() // "hello"
  ```
- super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。
  ```js
  // 报错
  const obj = {
    foo: super.foo // super 用在了属性中
  }
  // 报错
  const obj = {
    foo: () => super.foo // super 用在了函数中
  }
  // 报错
  const obj = {
    foo: function () {
      return super.foo // super 用在了函数中
    }
  }
  ```

### 对象的扩展运算符
- 解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。
  ```js
  let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
  x // 1
  y // 2
  z // { a: 3, b: 4 }
  ```
- 解构赋值必须是最后一个参数，否则会报错。
- 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。
- 扩展运算符的解构赋值，不能复制继承自原型对象的属性。
- 数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
  ```js
  let foo = { ...['a', 'b', 'c'] };
  foo
  // {0: "a", 1: "b", 2: "c"}
  ```
- 扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。
  ```js
  {...'hello'}
  // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
  ```
- 如果扩展运算符后面不是对象，则会自动将其转为对象。
  ```js
  // 等同于 {...Object(1)}
  {...1} // {}
  ```

### 对象的拷贝
```js
let aClone = { ...a, ...b };
// 等同于
let aClone = Object.assign({}, a, b);
// 只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

## 对象的新增方法
### Object.is方法
- 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
  ```js
  Object.is('foo', 'foo')  // true
  Object.is({}, {}) // false
  ```
- 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
  ```js
  +0 === -0 //true
  NaN === NaN // false

  Object.is(+0, -0) // false
  Object.is(NaN, NaN) // true
  ```
### Object.assign()
- 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。**如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。**
  ```js
  const target = { a: 1 };

  const source1 = { b: 2 };
  const source2 = { c: 3 };

  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
  ```
- 注意：
  ```js
  const obj = {a: 1};
  Object.assign(obj) === obj // true

  typeof Object.assign(2) // "object"

  Object.assign(undefined) // 报错
  Object.assign(null) // 报错

  // 非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同
  // 首先，这些参数都会转成对象，如果无法转成对象，就会跳过。
  // 这意味着，如果undefined和null不在首参数，就不会报错。
  let obj = {a: 1};
  Object.assign(obj, undefined) === obj // true
  Object.assign(obj, null) === obj // true

  const v1 = 'abc';
  const v2 = true;
  const v3 = 10;
  const obj = Object.assign({}, v1, v2, v3);
  console.log(obj); // { "0": "a", "1": "b", "2": "c" }
  ```
- Object.assign拷贝的属性是有限制的，**只拷贝源对象的自身属性**（**不拷贝继承属性**），也**不拷贝不可枚举的属性**（enumerable: false）。**属性名为 Symbol 值的属性，也会被Object.assign拷贝。**
  ```js
  Object.assign({b: 'c'},
  Object.defineProperty({}, 'invisible', {
      enumerable: false,
      value: 'hello'
    })
  )
  // { b: 'c' }

  Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
  // { a: 'b', Symbol(c): 'd' }
  ```
- Object.assign方法实行的是**浅拷贝**，而不是深拷贝。也就是说，**如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用**。嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是**替换**，而不是添加。
  ```js
  const obj1 = {a: {b: 1}};
  const obj2 = Object.assign({}, obj1);
  obj1.a.b = 2;
  obj2.a.b // 2

  const target = { a: { b: 'c', d: 'e' } }
  const source = { a: { b: 'hello' } }
  Object.assign(target, source)
  // { a: { b: 'hello' } }
  ```
- Object.assign可以用来处理数组，但是会把数组视为对象。
  ```js
  Object.assign([1, 2, 3], [4, 5])
  // [4, 5, 3]
  ```
- Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
  ```js
  const source = {
    get foo() { return 1 }
  };
  const target = {};
  Object.assign(target, source)
  // { foo: 1 } // 只复制值 而不是 取值函数
  ```

### Object.getOwnPropertyDescriptors()
- 返回某个对象属性的描述对象（descriptor）
  ```js
  const obj = {
    foo: 123,
    get bar() { return 'abc' }
  };

  Object.getOwnPropertyDescriptors(obj)
  // { foo:
  //    { value: 123,
  //      writable: true,
  //      enumerable: true,
  //      configurable: true },
  //   bar:
  //    { get: [Function: get bar],
  //      set: undefined,
  //      enumerable: true,
  //      configurable: true } }
  ```

### __proto__属性
- __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。
  ```js
  // es5 的写法
  const obj = {
    method: function() { ... }
  };
  obj.__proto__ = someOtherObj;

  // es6 的写法
  var obj = Object.create(someOtherObj);
  obj.method = function() { ... };
  ```

### Object.setPrototypeOf()
- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。
  ```js
  Object.setPrototypeOf(object, prototype)
  ```

### Object.getPrototypeOf()
- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。
  ```js
  function Rectangle() {
    // ...
  }
  const rec = new Rectangle();

  Object.getPrototypeOf(rec) === Rectangle.prototype
  // true

  Object.setPrototypeOf(rec, Object.prototype);
  Object.getPrototypeOf(rec) === Rectangle.prototype
  // false
  ```

### keys values entries fromEntries
- Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
  ```js
  var obj = { foo: 'bar', baz: 42 };
  Object.keys(obj)
  // ["foo", "baz"]
  ```
- Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
  ```js
  const obj = { foo: 'bar', baz: 42 };
  Object.values(obj)
  // ["bar", 42]
  ```
- Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
  ```js
  const obj = { foo: 'bar', baz: 42 };
  Object.entries(obj)
  // [ ["foo", "bar"], ["baz", 42] ]
  ```
- Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
  ```js
  Object.fromEntries([
    ['foo', 'bar'],
    ['baz', 42]
  ])
  // { foo: "bar", baz: 42 }
  ```

## Symbol
### 概述
- ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
  ```js
  let s = Symbol();
  typeof s // "symbol"
  // 变量s就是一个独一无二的值。
  // typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。
  ```
- Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol **是一个原始类型的值**，不是对象。也就是说，由于 **Symbol 值不是对象，所以不能添加属性**。基本上，它是一种类似于字符串的数据类型。
- Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。主要是为了在控制台显示，或者转为字符串时，比较容易区分。
  ```js
  let s1 = Symbol('foo');
  s1 // Symbol(foo)
  s1.toString() // "Symbol(foo)"

  // 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，
  // 将其转为字符串，然后才生成一个 Symbol 值。
  const obj = {
    toString() {
      return 'abc';
    }
  };
  const sym = Symbol(obj);
  sym // Symbol(abc)
  ```
- Symbol函数的参数只是表示对当前 Symbol 值的描述，因此**相同参数的Symbol函数的返回值是不相等的。**
  ```js
  let s1 = Symbol();
  let s2 = Symbol();
  s1 === s2 // false

  let s1 = Symbol('foo');
  let s2 = Symbol('foo');
  s1 === s2 // false
  ```
- 注意：
  
  1. Symbol 值不能与其他类型的值进行运算，会报错。
  2. Symbol 值可以显式转为字符串。
  3. Symbol 值也可以转为布尔值，但是不能转为数值。 
   
    
### Symbol.prototype.description
- ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。
  ```js
  const sym = Symbol('foo');
  sym.description // "foo"

  // 不适用descriptioin时怎么获取描述
  const sym = Symbol('foo');
  String(sym) // "Symbol(foo)"
  sym.toString() // "Symbol(foo)"
  ```

### 作为属性名的Symbol
- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
  ```js
  let mySymbol = Symbol();

  let a = {};
  a[mySymbol] = 'Hello!';

  let a = {
    [mySymbol]: 'Hello!';
  };

  let a = {};
  Object.defineProperty(a, mySymbol, { value: 'Hello!' });
  ```
- 注意:
  
  1. Symbol 值作为对象属性名时，不能用点运算符。
  2. 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
  3. Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。

## Set
### 用法
- ES6 提供了新的数据结构 Set。它类似于数组，但是**成员的值都是唯一的，没有重复的值**。Set本身是一个构造函数，用来生成 Set 数据结构。
  ```js
  const s = new Set();
  // Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化
  const set = new Set([1, 2, 3, 4, 4]);
  ```
- 去除数组重复成员，去除字符串里面的重复字符
  ```js
  [...new Set(array)]
  Array.from(new Set(array))
  [...new Set('ababbc')].join('')  
  ```
- 向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。

### 实例的属性跟方法
- Set.prototype.constructor：构造函数，默认就是Set函数。
- Set.prototype.size：返回Set实例的成员总数。
- Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
- Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
- Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
- Set.prototype.clear()：清除所有成员，没有返回值。
- Set 遍历方法（用于遍历成员） Set的遍历顺序就是插入顺序
  - Set.prototype.keys()：返回键名的遍历器
  - Set.prototype.values()：返回键值的遍历器
  - Set.prototype.entries()：返回键值对的遍历器
  - Set.prototype.forEach()：使用回调函数遍历每个成员
  - for of 

### WeakSet
- WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先，**WeakSet 的成员只能是对象，而不能是其他类型的值**。其次，**WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用**，也就是说，**如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。**
- WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。可以接受一个数组或类似数组的对象作为参数。自动成为 WeakSet 实例对象的成员。
  ```js
  const ws = new WeakSet();

  const a = [[1, 2], [3, 4]];
  const ws = new WeakSet(a);
  // WeakSet {[1, 2], [3, 4]}
  ```
- WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
- WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中
- **WeakSet 没有size属性，没有办法遍历它的成员。**
  
  **原因**：WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

## Map
### 用法
- ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是键的范围不限于字符串，**各种类型的值（包括对象）都可以当作键**。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
  ```js
  const map = new Map([
    ['name', '张三'],
    ['title', 'Author']
  ]);
  ```
- 如果读取一个未知的键，则返回undefined。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
  
### 实例的属性跟方法
- size属性返回 Map 结构的成员总数。
- set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。
- get方法读取key对应的键值，如果找不到key，返回undefined。
- has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
- delete方法删除某个键，返回true。如果删除失败，返回false。
- clear方法清除所有成员，没有返回值。
- 遍历方法
  - Map.prototype.keys()：返回键名的遍历器。
  - Map.prototype.values()：返回键值的遍历器。
  - Map.prototype.entries()：返回所有成员的遍历器。
  - Map.prototype.forEach()：遍历 Map 的所有成员。
  - for of 同 entries
- Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。
  ```js
  const map = new Map([
    [1, 'one'],
    [2, 'two'],
    [3, 'three'],
  ]);
  [...map] // [[1,'one'], [2, 'two'], [3, 'three']]
  ```

### WeakMap
- 首先，WeakMap只接受**对象作为键名**（**null除外**），不接受其他类型的值作为键名
- 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。
它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

- WeakMap 与 Map 在 API 上的区别主要是两个，一是**没有遍历操作**（即没有keys()、values()和entries()方法），也没有size属性。
- 因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。
- WeakMap只有四个方法可用：get()、set()、has()、delete()。
  
## Proxy
### 概念
- Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
- Proxy 对象的所有用法，都是 new Proxy(target, handler)，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。如果 handler 没有设置任何拦截，那就等同于直接通向原对象。
  ```js
  var proxy = new Proxy({}, {
    get: function(target, property) {
      return 35;
    }
  });
  ```
### handler 支持的拦截操作
```js
get(target, propKey, receiver)：
// 拦截对象属性的读取，比如proxy.foo和proxy['foo']。

set(target, propKey, value, receiver)：
// 拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

has(target, propKey)：
// 拦截propKey in proxy的操作，返回一个布尔值。

deleteProperty(target, propKey)：
// 拦截delete proxy[propKey]的操作，返回一个布尔值。

ownKeys(target)：
// 拦截Object.getOwnPropertyNames(proxy)、
// Object.getOwnPropertySymbols(proxy)、
// Object.keys(proxy)、for...in循环，返回一个数组。
// 该方法返回目标对象所有自身的属性的属性名，
// 而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

getOwnPropertyDescriptor(target, propKey)：
// 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。

defineProperty(target, propKey, propDesc)：
// 拦截Object.defineProperty(proxy, propKey, propDesc）、
// Object.defineProperties(proxy, propDescs)，返回一个布尔值。

preventExtensions(target)：
// 拦截Object.preventExtensions(proxy)，返回一个布尔值。

getPrototypeOf(target)：
// 拦截Object.getPrototypeOf(proxy)，返回一个对象。

isExtensible(target)：
// 拦截Object.isExtensible(proxy)，返回一个布尔值。

setPrototypeOf(target, proto)：
// 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。

// 如果目标对象是函数，那么还有两种额外操作可以拦截。
apply(target, object, args)：
// 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、
// proxy.call(object, ...args)、proxy.apply(...)。

construct(target, args)：
// 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
```

### Proxy.revocable()
 - 返回一个可取消的 Proxy 实例
  ```js
  let target = {};
  let handler = {};
  let {proxy, revoke} = Proxy.revocable(target, handler);
  proxy.foo = 123;
  proxy.foo // 123
  revoke();
  proxy.foo // TypeError: Revoked
  ```
### This 问题
```js
const target = {
  m: function () {
    console.log(this === proxy);
  }
};
const handler = {};
const proxy = new Proxy(target, handler);
target.m() // false
proxy.m()  // true
```

## Reflect
### 概述
- 将对象的一系列方法统一放到 Reflect上
  ```js
  Reflect.defineProperty(target, property, attributes) // 返回 true false
  // 代替 Object.defineProperty(target, property, attributes);
  Reflect.has(Object, 'assign') // 返回 true false
  // 代替 'assign' in Object
  Reflect.deleteProperty(Object, name) // 返回 true false
  // 代替 delete obj[name] 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回 true，删除失败，被删除的属性依然存在，返回 false。
  Reflect.apply(target, thisArg, args)
  /// Reflect.apply 方法等同于 Function.prototype.apply.call(func, thisArg, args)，用于绑定 this 对象后执行给定函数。
  Reflect.construct(target, args)
  // 提供了一种不使用new，来调用构造函数的方法。
  Reflect.get(target, name, receiver)
  // 如果 name 属性部署了读取函数（getter），则读取函数的 this 绑定 receiver
  Reflect.set(target, name, value, receiver)  
  // name 属性设置了赋值函数，则赋值函数的 this 绑定 receiver。
  Reflect.ownKeys(target)
  Reflect.isExtensible(target)
  // Reflect.isExtensible 方法对应 Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
  Reflect.preventExtensions(target)
  // Reflect.preventExtensions 对应 Object.preventExtensions 方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
  Reflect.getOwnPropertyDescriptor(target, name)
  Reflect.getPrototypeOf(target)
  // 用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
  Reflect.setPrototypeOf(target, prototype)
  // 设置目标对象的原型（prototype）返回一个布尔值，表示是否设置成功。
  ```
- **Reflect对象的方法与Proxy对象的方法一一对应**，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就**让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为**，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。

## Promise
### 介绍
- Promise 是异步编程的一种解决方案。
- 优点
  - Promise 将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
  - 提供了方便的错误处理方式
  - 解决了多个异步任务并发的问题
- 缺点
  - 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
  - 处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
### 用法
- ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
  ```js
  const promise = new Promise(function(resolve, reject) {
  // ... some code
    if (/* 异步操作成功 */){
      resolve(value);
    } else {
      reject(error);
    }
  });
  ```
- Promise.prototype.then() 返回一个新的Promise实，因此可以采用链式写法，即then方法后面再调用另一个then方法。
- Promise.prototype.catch() 用于指定发生错误时的回调函数。
- Promise.prototype.finally() 不管 Promise 对象最后状态如何，都会执行的操作。
- Promise.all() 将多个 Promise 实例，包装成一个新的 Promise 实例，全部都 fulfilled 之后新的 promise 才会fulfilled，一个出现 rejected 就会 rejected
- Promise.race() 将多个 Promise 实例，包装成一个新的 Promise 实例，一个实例率先改变状态，最终状态就会跟着转变。
- Promise.allSettled() 接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。
- Promise.any() 接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。
- Promise.resolve() 将现有对象转为 Promise 对象
- Promise.reject() 返回一个新的 Promise 实例，该实例的状态为rejected。
  
## iterator 遍历器
### 概念
- 遍历器（Iterator）就是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
- Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
  
### Iterator 的遍历过程：
1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。
   
每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。

### 默认 Iterator 接口 
- ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。
  ```js
  const obj = {
    [Symbol.iterator] : function () {
      return {
        next: function () {
          return {
            value: 1,
            done: true
          };
        }
      };
    }
  };
  ```
- ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。
  - Array
  - Map
  - Set
  - String
  - TypedArray
  - 函数的 arguments 对象
  - NodeList 对象
  
### 调用 Iterator 接口的场合
- 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。
- 扩展运算符（...）也会调用默认的 Iterator 接口。

### 遍历器对象的 return()，throw() 
- return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。
- 下面的两种情况，都会触发执行return方法。
  ```js
  for (let line of readLinesSync(fileName)) {
    console.log(line);
    break; // break 
  }
  for (let line of readLinesSync(fileName)) {
    console.log(line);
    throw new Error(); // throw
  }
  ```
### for...of 循环
- ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为**遍历所有数据结构的统一的方法。**
- 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的**Symbol.iterator**方法。
- for...of循环可以使用的范围包括**数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。**

## Generator
### 概念
- Generator 函数是 ES6 提供的一种异步编程解决方案
- 执行 Generator 函数会返回一个遍历器对象，是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。
- Generator 函数是一个普通函数，但是有两个特征。
  - function关键字与函数名之间有一个星号
  - 函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
  ```js
  function* helloWorldGenerator() {
    yield 'hello';
    yield 'world';
    return 'ending';
  }
  var hw = helloWorldGenerator();
  hw.next() // { value: 'hello', done: false }
  hw.next() // { value: 'world', done: false }
  hw.next() // { value: 'ending', done: true }  
  hw.next() // { value: undefined, done: true }  
  ```
### yield 表达式
- 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。**yield表达式就是暂停标志**。
- 遍历器对象的next方法的运行逻辑如下。
  - 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
  - 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
  - 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
  - 如果该函数没有return语句，则返回的对象的value属性值为undefined。
- 与Iterator接口的关系
  - 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。
  - 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。	
  ```js
  var myIterable = {};
  myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
  };
  [...myIterable] // [1, 2, 3]
  // --------------------------------------- 
  function* gen(){
    // some code
  }
  var g = gen();
  g[Symbol.iterator]() === g
  // true
  ```
### next 方法的参数
- yield表达式本身没有返回值，或者说总是返回undefined。**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。**
- 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。
  ```js
  function* f() {
    for(var i = 0; true; i++) {
      var reset = yield i;
      if(reset) { i = -1; }
    }
  }
  var g = f();
  g.next() // { value: 0, done: false }
  g.next() // { value: 1, done: false }
  g.next(true) // { value: 0, done: false }
  ```

### for...of 循环
- for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。
  ```js
  function* foo() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    return 6;
  }
  for (let v of foo()) {
    console.log(v);
  }
  // 1 2 3 4 5
  ```
- 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。
  ```js
  function* objectEntries() {
    let propKeys = Object.keys(this);
    for (let propKey of propKeys) {
      yield [propKey, this[propKey]];
    }
  }
  let jane = { first: 'Jane', last: 'Doe' };
  jane[Symbol.iterator] = objectEntries;
  for (let [key, value] of jane) {
    console.log(`${key}: ${value}`);
  }
  // first: Jane
  // last: Doe
  ```

### Generator.prototype.throw() 
- Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
  ```js
  var g = function* () {
    try {
      yield;
    } catch (e) {
      console.log('内部捕获', e); // 内部捕获 a
    }
  };
  var i = g();
  i.next();
  try {
    i.throw('a');
    i.throw('b');
  } catch (e) {
    console.log('外部捕获', e); // 外部捕获 b
  }
  // 遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。
  // i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，
  // 不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，
  // 被函数体外的catch语句捕获。    
  ```
- 不要混淆遍历器对象的throw方法和全局的throw命令 
  ```js
  var g = function* () {
    while (true) {
      try {
        yield;
      } catch (e) {
        if (e != 'a') throw e;
        console.log('内部捕获', e);
      }
    }
  };
  var i = g();
  i.next();
  try {
    throw new Error('a');
    throw new Error('b');
  } catch (e) {
    console.log('外部捕获', e);
  }
  // 外部捕获 [Error: a]
  // 之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，
  // 就不会再继续try代码块里面剩余的语句了。
  ```
- Generator 函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。
- throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。
- throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。

### Generator.prototype.return()
- Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。如果return方法调用时，不提供参数，则返回值的value属性为undefined。
  ```js
  function* gen() {
    yield 1;
    yield 2;
    yield 3;
  }
  var g = gen();
  g.next()        // { value: 1, done: false }
  g.return('foo') // { value: "foo", done: true }
  g.next()        // { value: undefined, done: true }
  ```

### yield* 表达式
- 如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。
  ```js
  function* foo() {
    yield 'a';
    yield 'b';
  }

  function* bar() {
    yield 'x';
    // 手动遍历 foo()
    for (let i of foo()) {
      console.log(i);
    }
    yield 'y';
  }

  for (let v of bar()){
    console.log(v);
  }
  // x
  // a
  // b
  // y
  ```
- yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。
  ```js
  function* inner() {
    yield 'hello!';
  }

  function* outer1() {
    yield 'open';
    yield inner();
    yield 'close';
  }

  var gen = outer1()
  gen.next().value // "open"
  gen.next().value // 返回一个遍历器对象
  gen.next().value // "close"

  function* outer2() {
    yield 'open'
    yield* inner()
    yield 'close'
  }

  var gen = outer2()
  gen.next().value // "open"
  gen.next().value // "hello!"
  gen.next().value // "close"
  // 上面例子中，outer2使用了yield*，outer1没使用。
  // 结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。
  ```
- 使用 yield* 遍历二叉树
  ```js
  // 下面是二叉树的构造函数，
  // 三个参数分别是左树、当前节点和右树
  function Tree(left, label, right) {
    this.left = left;
    this.label = label;
    this.right = right;
  }

  // 下面是中序（inorder）遍历函数。
  // 由于返回的是一个遍历器，所以要用generator函数。
  // 函数体内采用递归算法，所以左树和右树要用yield*遍历
  function* inorder(t) {
    if (t) {
      yield* inorder(t.left);
      yield t.label;
      yield* inorder(t.right);
    }
  }

  // 下面生成二叉树
  function make(array) {
    // 判断是否为叶节点
    if (array.length == 1) return new Tree(null, array[0], null);
    return new Tree(make(array[0]), array[1], make(array[2]));
  }
  let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);

  // 遍历二叉树
  var result = [];
  for (let node of inorder(tree)) {
    result.push(node);
  }

  result
  // ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  ```

### Generator 函数的this
- Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。
  ```js
  function* g() {}

  g.prototype.hello = function () {
    return 'hi!';
  };

  let obj = g();

  obj instanceof g // true
  obj.hello() // 'hi!'
  ```
- Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。
  ```js
  function* g() {
    this.a = 11;
  }

  let obj = g();
  obj.next();
  obj.a // undefined
  ```
- Generator 函数也不能跟new命令一起用，会报错。
- 让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this
  ```js
  function* gen() {
    this.a = 1;
    yield this.b = 2;
    yield this.c = 3;
  }

  function F() {
    return gen.call(gen.prototype);
  }

  var f = new F();

  f.next();  // Object {value: 2, done: false}
  f.next();  // Object {value: 3, done: false}
  f.next();  // Object {value: undefined, done: true}

  f.a // 1
  f.b // 2
  f.c // 3
  ```

### 应用
- 异步操作的同步化表达，Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。

## Generator 的异步应用
- ES6 诞生以前，异步编程的方法，大概有下面四种。
  - 回调函数
  - 事件监听
  - 发布/订阅
  - Promise 对象
- Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。
  
### 异步
- 所谓"异步"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

### 回调函数
- JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是"重新调用"。
  ```js
  fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
    if (err) throw err;
    console.log(data);
  });
  // 为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？
  // 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。
  ```
- 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为"回调函数地狱"（callback hell）。
  
### Promise
- Promise 对象就是为了解决回调函数地狱提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。
- Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。

### Generator
- 协程
  - "协程"（coroutine），意思是多个线程互相协作，完成异步任务。
  - 第一步，协程A开始执行。
  - 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
  - 第三步，（一段时间后）协程B交还执行权。
  - 第四步，协程A恢复执行。
- Generator 函数可以将异步操作表示得很简洁，但是流程管理却不方便。
- Generator 的流程管理，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。
  ```js
  // 基于回调函数
  // 通过柯里化实现
  fs.readFile(fileName, callback); // 正常 readFile 函数
  var Thunk = function (fileName) {
    return function (callback) {
      return fs.readFile(fileName, callback);
    };
  };
  var readFileThunk = Thunk(fileName); // 柯里化后 只需传入回调函数 便会执行
  var gen = function* (){
    var r1 = yield readFileThunk('/etc/fstab');
    var r2 = yield readFileThunk('/etc/shells');
  };
  function run(fn){
    let gen = fn()
    function next(err,data){
      let res = gen.next(data)
      if(res.done)return res.value
      res.value(next)
    }
    next()
  }
  run(gen)
  ```
  ```js
  // 基于 promise
  var readFile = function (fileName){
    return new Promise(function (resolve, reject){
      fs.readFile(fileName, function(error, data){
        if (error) return reject(error);
        resolve(data);
      });
    });
  };
  var gen = function* (){
    var f1 = yield readFile('/etc/fstab');
    var f2 = yield readFile('/etc/shells');
  };
  function co(fn){
    let gen = fn()
    function next(data){
      let res = gen.next(data)
      if(res.done) return res.value
      res.value.then(next)
    }
    next()
  }
  co(gen)
  ```

## async 函数
### 它就是 Generator 函数的语法糖
```js
const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
};
```

### 优点
- 内置执行器，Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。
- 更好的语义，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
- 更广的适用性，co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
- 返回值是 Promise，async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。

### 实现原理
- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。
  ```js
  async function fn(args) {
    // ...
  }

  // 等同于

  function fn(args) {
    return spawn(function* () { // generator 函数
      // ...
    });
  }
  function spawn(genF) { // 自送执行器
    return new Promise(function(resolve, reject) {
      const gen = genF();
      function step(nextF) {
        let next;
        try {
          next = nextF();
        } catch(e) {
          return reject(e);
        }
        if(next.done) {
          return resolve(next.value);
        }
        Promise.resolve(next.value).then(function(v) {
          step(function() { return gen.next(v); });
        }, function(e) {
          step(function() { return gen.throw(e); });
        });
      }
      step(function() { return gen.next(undefined); });
    });
  }
  ```

## 类
- ES6 引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。
- 类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。**类的内部所有定义的方法，都是不可枚举的（non-enumerable）。**
- constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。
- constructor 方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
- 生成类的实例的写法，与 ES5 完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。
- 在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
- 
  ```js
  let prop = 'lee'
  const myClass = class Me { // class 表达式
    constructor() {
      // ...
    }
    get prop() {
      return 'getter';
    }
    set prop(value) {
      console.log('setter: '+value);
    }
    [prop](){} // 属性表达式
  }

  let inst = new MyClass();
  ```
- 注意点：
  - 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你	的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。
  - 类不存在变量提升（hoist）。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。
  - name属性总是返回紧跟在class关键字后面的类名。
    ```js
    class Point {}
    Point.name // "Point"
    ```
  - 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。
  - 类的方法内部如果含有this，它默认指向类的实例。但是一旦单独使用该方法，很可能报错。
  
### 静态方法
- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上**static**关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
- 如果静态方法包含this关键字，这个this指的是类，而不是实例。
- 父类的静态方法，可以被子类继承。
  ```js
  class Foo {
    static classMethod() {
      return 'hello';
    }
  }
  Foo.classMethod() // 'hello'
  var foo = new Foo();
  foo.classMethod() // TypeError: foo.classMethod is not a function
  ```

### 实例属性的新写法
- 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。
  ```js
  class IncreasingCounter {
    constructor() {
      this._count = 0;
    }
  }
  class IncreasingCounter {
    _count = 0;
  }
  ```
### 静态属性
- 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。
  ```js
  class Foo {}
  Foo.prop = 1;
  Foo.prop // 1
  ```

### new.target属性
- new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此**这个属性可以用来确定构造函数是怎么调用的。**

## Class 的继承
- Class 可以通过extends关键字实现继承。
- 子类必须在 constructor 方法中调用 **super** 方法，否则新建实例时会报错。这是因为**子类自己的 this 对象，必须先通过父类的构造函数完成塑造**，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到this对象。
  ```js
  class ColorPoint extends Point {
    constructor(x, y, color) {
      super(x, y); // 调用父类的constructor(x, y)
      this.color = color;
    }
    toString() {
      return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
  }
  ```
- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
- ES6 的继承机制完全不同，实质是先将父类实例属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。
- 在子类的构造函数中，**只有调用super之后，才可以使用this关键字，否则会报错。**这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。

### Object.getPrototypeOf()
- Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类
  ```js
  Object.getPrototypeOf(ColorPoint) === Point // true  
  ```
### super关键字
- super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。
- 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。
  ```js
  class A {}

  class B extends A {
    constructor() {
      super(); // super()在这里相当于A.prototype.constructor.call(this)。
    }
  }
  ```
- 第二种情况，super作为对象时在普通方法中指向父类的原型对象；在静态方法中，指向父类。
- ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。
  ```js
  class A {
    constructor() {
      this.x = 1;
    }
    print() {
      console.log(this.x);
    }
  }

  class B extends A {
    constructor() {
      super();
      this.x = 2;
    }
    m() {
      super.print(); // this指向当前的子类实例 super 指向父类原型对象
    }
  }

  let b = new B();
  b.m() // 2
  ```
- 如果通过super对某个属性赋值，**这时 super 就是 this**，赋值的属性会变成子类实例的属性。
  ```js
  class A {
    constructor() {
      this.x = 1;
    }
  }

  class B extends A {
    constructor() {
      super();
      this.x = 2;
      super.x = 3;
      console.log(super.x); // undefined
      console.log(this.x); // 3
    }
  }

  let b = new B();
  ```
- super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。
- 子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。
  ```js
  class A {
    constructor() {
      this.x = 1;
    }
    static print() {
      console.log(this.x);
    }
  }

  class B extends A {
    constructor() {
      super();
      this.x = 2;
    }
    static m() {
      super.print(); // super 指向当前父类 this 指向子类
    }
  }

  B.x = 3;
  B.m() // 3
  ```

### prototype 属性和 __proto__ 属性
- Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__ 属性，因此同时存在两条继承链。
- 1.子类的 __proto__ 属性，表示构造函数的继承，总是指向父类。
- 2.子类 prototype 属性的 __proto__ 属性，表示方法的继承，总是指向父类的 prototype 属性.
  ```js
  class A {}
  class B extends A {}

  B.__proto__ === A // true
  B.prototype.__proto__ === A.prototype // true
  // 这两条继承链，可以这样理解：
  // 作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；
  // 作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。
  ```
- 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。

## Module 
### 概述
- 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能。
- ES6 模块的设计思想是尽量的**静态化**，使得**编译时就能确定模块的依赖关系，以及输入和输出的变量**。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
- ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。
  ```js
  // CommonJS模块
  let { stat, exists, readFile } = require('fs');
  // 等同于
  let _fs = require('fs');
  let stat = _fs.stat;
  let exists = _fs.exists;
  let readfile = _fs.readfile;
  // 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），
  // 然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，
  // 因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
  // ES6模块

  import { stat, exists, readFile } from 'fs';
  // 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。
  // 这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，
  // 效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，
  // 因为它不是对象。
  ```

### export
- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，**就必须使用 export关键字输出该变量。**
- 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。	
  ```js
  export var firstName = 'Michael';
  export { firstName };
  export function multiply(x, y) {
    return x * y;
  };
  export {firstName as f1}
  ```
- **需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。**
  ```js
  // 报错
  export 1;
  var m = 1;
  export m;
  function f() {}
  export f;
  ```
- export语句输出的接口，与其对应的值是**动态绑定关系**，即通过该接口，**可以取到模块内部实时的值**。
- export命令可以出现在模块的任何位置，只要**处于模块顶层**就可以。**如果处于块级作用域内，就会报错**，下一节的import命令也是如此。**这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。**
  
### import
- 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。
- 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。
- import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。但是，如果a是一个对象，改写a的属性是允许的。
  ```js
  import { firstName, lastName, year as newYear } from './profile.js';
  firstName = 'lee' // 报错 Syntax Error : 'firstName' is read-only;
  ```
- 注意，**import命令具有提升效果，会提升到整个模块的头部，首先执行。**
- 由于**import是静态执行，所以不能使用表达式和变量**，这些只有在运行时才能得到结果的语法结构。
  
### 模块的整体加载
- 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
  ```js
  import * as lee from 'lee';
  ```

### export default
- export default命令，为模块指定默认输出。
- 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
- export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，**因此export default命令只能使用一次**。
  ```js
  // modules.js
  function add(x, y) {
    return x * y;
  }
  export {add as default};
  // 等同于
  // export default add;

  // app.js
  import { default as foo } from 'modules';
  // 等同于
  // import foo from 'modules';

  // 正是因为export default命令其实只是输出一个叫做default的变量，
  // 所以它后面不能跟变量声明语句。
  // 正确
  export var a = 1;

  // 正确
  var a = 1;
  export default a;

  // 错误
  export default var a = 1;
  ```
- 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样
  ```js
  import _, { each, forEach } from 'lodash';
  ```
### export与import的复合写法
- 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
- 但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致**当前模块不能直接使用foo和bar。**
  ```js
  export { foo, bar } from 'my_module';
  ```
- 模块的接口改名和整体输出，也可以采用这种写法。
  ```js
  export { foo as myFoo } from 'my_module';
  export * from 'my_module';
  // 默认接口
  export { default } from 'foo';
  // 具名接口改为默认接口的写法如下。
  export { es6 as default } from './someModule';
  // 默认接口也可以改名为具名接口。
  export { default as es6 } from './someModule';
  ```

### import()
- import() 返回一个 Promise 对象。
  ```js
  const main = document.querySelector('main');
  import(`./section-modules/${someVariable}.js`)
    .then(module => {
      module.loadPageInto(main);
    })
    .catch(err => {
      main.textContent = err.message;
    });
  ```
- import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是**前者是异步加载，后者是同步加载**。
  
## Module 的加载实现
### 浏览器加载
- HTML 网页中，浏览器通过'<\script>'标签加载 JavaScript 脚本。
  ```js
  < type="application/javascript" src="path/to/myModule.js"></>
  ```
- 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<\script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许**脚本异步加载**，下面就是两种异步加载的语法。
  ```js
  < src="path/to/myModule.js" defer></>
  < src="path/to/myModule.js" async></>
  ```
- <\script>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。
- defer 与 async 的区别是
  - defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
  - async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
  - defer 是“渲染完再执行”，async 是“下载完就执行”。
  - 如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
### 浏览器加载 ES6 模块
- 浏览器加载 ES6 模块，也使用<\script>标签，但是要加入type="module"属性。
- 如果网页有多个<\script type="module">，它们会按照在页面出现的顺序依次执行。
  ```js
  <script  type="module" src="./foo.js"></script>
  // 浏览器对于带有type="module"的<script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。
  ```
- <\script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。
  ```js
  <script  type="module" src="./foo.js" async></script>
  // 一旦使用了async属性，<script type="module">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。
  ```
- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。
  ```js
  <script type="module">
    import utils from "./utils.js";
    // other code
  </script>
  // 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
  // 模块脚本自动采用严格模式，不管有没有声明use strict。
  // 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。
  // 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。
  // 同一个模块如果加载多次，将只执行一次。
  ```

### ES6模块与CommonJS模块的差异
- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
  ```js
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    counter: counter,
    incCounter: incCounter,
  };

  // 然后，在main.js里面加载这个模块。
  // main.js
  var mod = require('./lib');

  console.log(mod.counter);  // 3
  mod.incCounter();
  console.log(mod.counter); // 3
  // 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。
  // 这是因为mod.counter是一个原始类型的值，会被缓存。
  // 除非写成一个函数，才能得到内部变动后的值。

  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    get counter() {
      return counter
    },
    incCounter: incCounter,
  };
  // 上面代码中，输出的counter属性实际上是一个取值器函数。
  // 现在再执行main.js，就可以正确读取内部变量counter的变动了。
  ```
- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
  ```js
  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }

  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```